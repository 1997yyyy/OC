from flask import Flask, request, jsonify
import threading
import time
import requests

app = Flask(__name__)

# -------------------------------
# 任务 1：计算前 n 个斐波那契数
# -------------------------------
def fibonacci(n):
    if n <= 0:
        return []
    if n == 1:
        return [0]
    seq = [0, 1]
    while len(seq) < n:
        seq.append(seq[-1] + seq[-2])
    return seq

# -------------------------------
# 任务 2：判断一个数字是否为回文数字
# -------------------------------
def is_palindrome_number(num):
    s = str(num)
    return s == s[::-1]

# -------------------------------
# 任务 3：链表相关操作
# -------------------------------
class Node:
    def __init__(self, val):
        self.val = val
        self.next = None

def build_linked_list(lst):
    head = None
    prev = None
    for item in lst:
        node = Node(item)
        if head is None:
            head = node
        else:
            prev.next = node
        prev = node
    return head

def linked_list_to_list(head):
    result = []
    current = head
    while current:
        result.append(current.val)
        current = current.next
    return result

def reverse_linked_list(head):
    prev = None
    current = head
    while current:
        next_node = current.next
        current.next = prev
        prev = current
        current = next_node
    return prev

# -------------------------------
# REST API 接口
# -------------------------------
# 接口 1：返回前 n 个斐波那契数
@app.route('/api/fibonacci', methods=['GET'])
def api_fibonacci():
    n = request.args.get('n', type=int)
    if n is None or n <= 0:
        return jsonify({"error": "请提供一个大于0的自然数 n"}), 400
    return jsonify({"fibonacci": fibonacci(n)})

# 接口 2：判断数字是否是回文
@app.route('/api/palindrome', methods=['GET'])
def api_palindrome():
    number = request.args.get('number')
    if number is None:
        return jsonify({"error": "请传入参数 'number'"}), 400
    return jsonify({
        "number": number,
        "is_palindrome": (number == number[::-1])
    })

# 接口 3：链表反转
# 输入 JSON 形如：{"list": [1,2,3,4,5]}
@app.route('/api/reverse', methods=['POST'])
def api_reverse():
    data = request.get_json()
    if not data or 'list' not in data:
        return jsonify({"error": "JSON 中应包含键 'list' 对应一个数组"}), 400
    lst = data['list']
    head = build_linked_list(lst)
    reversed_head = reverse_linked_list(head)
    reversed_list = linked_list_to_list(reversed_head)
    return jsonify({
        "original": lst,
        "reversed": reversed_list
    })

# -------------------------------
# API 测试代码
# -------------------------------
def run_tests():
    # 等待1秒让 Flask 服务器启动
    time.sleep(1)
    print("Running API tests...")

    # 测试接口1：斐波那契数列
    fib_response = requests.get("http://localhost:5000/api/fibonacci", params={"n": 10})
    print("Fibonacci Response:", fib_response.json())

    # 测试接口2：回文验证
    pal_response1 = requests.get("http://localhost:5000/api/palindrome", params={"number": "12321"})
    print("Palindrome (12321) Response:", pal_response1.json())
    pal_response2 = requests.get("http://localhost:5000/api/palindrome", params={"number": "12345"})
    print("Palindrome (12345) Response:", pal_response2.json())

    # 测试接口3：链表反转
    test_list = {"list": [1, 2, 3, 4, 5]}
    reverse_response = requests.post("http://localhost:5000/api/reverse", json=test_list)
    print("Linked List Reverse Response:", reverse_response.json())

if __name__ == '__main__':
    # 在单独线程中启动 Flask 服务，避免阻塞后续 API 测试代码执行
    server_thread = threading.Thread(target=lambda: app.run(debug=False, port=5000, use_reloader=False))
    server_thread.daemon = True
    server_thread.start()

    # 运行测试
    run_tests()

    # 保持主线程运行几秒钟以确保服务器输出能看清；实际部署时可以去掉
    time.sleep(2)
